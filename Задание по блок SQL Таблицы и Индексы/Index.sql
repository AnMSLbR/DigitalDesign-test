/*
	Задача 1.

 Кластерный индекс на столбце ID с первичным ключом,
 Неуникальный некластерный индекс idx_Employees_TabNum,
 Уникальный некластерный индекс на столбце Email создаваемый с помощью ключевого слова UNIQUE

	Задача 2.

Индекс по полю TabNum создает отсортированный список значений TabNum и ссылок на соответствующие записи в таблице. Поиск по индексу позволяет быстро найти все записи, удовлетворяющие условию TabNum = 1, без необходимости просмотра каждой строки таблицы. Использование индекса позволяет минимизировать количество операций чтения данных с диска, так как индекс содержит только необходимые для поиска столбцы (TabNum) и ссылки на соответствующие строки в таблице. 

Поиск с использованием индекса по полю TabNum может быть неэффективным если в таблице сотрудников большинство записей имеют одинаковое значение TabNum, тогда использование индекса может не принести значительных выгод. В этом случае, поиск по индексу может быть медленнее, чем сканирование всей таблицы.
Если таблица Employees подвержена частым операциям вставки, обновления и удаления записей, то индекс по полю TabNum должен быть обновлен соответствующим образом. Это может вызвать дополнительные затраты на обслуживание индекса и ухудшить производительность операций записи.

Поскольку TabNum можно считать уникальным и запрос должен возвращать только одну запись, то для прироста производительности можно использовать некластерный индекс на столбце TabNum, поскольку он эффективен для поиска по конкретным значениям:
CREATE NONCLUSTERED INDEX idx_Employees_TabNum ON Employees (TabNum);
Также можно использовать ключевое слово TOP 1 в запросе, чтобы прекратить поиск после нахождения первой соответствующей записи.

	Задача 3.

Добавление индекса на столбец DateOfBirth в таблице может значительно улучшить скорость исполнения запроса, особенно если таблица содержит большое количество строк. Индекс позволяет базе данных быстро найти строки, удовлетворяющие условиям запроса, без необходимости полного сканирования всех записей.
Вместо использования функции DATEPART можно изменить условие на 
WHERE DateOfBirth >= '1998-01-01' AND DateOfBirth < '1999-01-01'
чтобы оно соответствовало диапазону дат в течение всего 1998 года. Такое изменение позволит использовать индекс более эффективно.

	Задача 4.

Добавление составного индекса на столбцы LastName и DateOfBirth в таблице Employees может оказать положительное влияние на скорость выполнения запроса, особенно если оба столбца активно используются в условиях фильтрации и сортировки.
Можно внести некоторые изменения в индекс или запрос:
- Можно рассмотреть создание индекса с сортировкой в порядке убывания для столбца DateOfBirth, чтобы избежать дополнительной операции сортировки.
- В запросе можно использовать операторы сравнения вместо ORDER BY для фильтрации по дате рождения.

	Задача 5.

Добавление составного индекса на столбцы LastName и DateOfBirth в таблице Employees может иметь некоторое влияние на скорость выполнения запроса, однако в данном  запросе он может не использоваться эффективно из-за отсутствия фильтрации по фамилии (LastName). 
Можно внести некоторые изменения в индекс или запрос:
- Удалить составной индекс или создать дополнительный индекс только на столбце DateOfBirth.
- Если запросы с фильтрацией по дате рождения выполняются часто и требуют высокой производительности, можно рассмотреть предварительную обработку данных и добавление дополнительного столбца, содержащего только год рождения. Затем создать индекс на новом столбце и изменить запрос, чтобы сравнивать с этим столбцом.

	Задача 6.
	
Использование дополнительного условия LastName = N'Иванов' во втором запросе может повлиять на эффективность индекса. Если в таблице есть много записей с фамилией "Иванов" и для них не создан отдельный индекс, то запросу может потребоваться просмотреть большое количество строк, чтобы найти все строки, удовлетворяющие обоим условиям. В этом случае индекс на столбцах Gender и DateOfBirth может быть менее эффективным. В этом случае лучше создать составной индекс, включив в него сразу все столбцы Gender, DateOfBirth и LastName, которые указывались в предложении WHERE.
*/