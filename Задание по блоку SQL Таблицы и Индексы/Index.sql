/*
	Задача 1.

 Кластерный индекс на столбце ID с первичным ключом,
 Неуникальный некластерный индекс idx_Employees_TabNum,
 Уникальный некластерный индекс на столбце Email создаваемый с помощью ключевого слова UNIQUE

	Задача 2.

Индекс по полю TabNum создает отсортированный список значений TabNum и ссылок на соответствующие записи в таблице. Поиск по индексу позволяет быстро найти все записи, удовлетворяющие условию TabNum = 1, без необходимости просмотра каждой строки таблицы. Использование индекса позволяет минимизировать количество операций чтения данных с диска, так как индекс содержит только необходимые для поиска столбцы (TabNum) и ссылки на соответствующие строки в таблице. 

Поиск с использованием индекса по полю TabNum может быть неэффективным если в таблице сотрудников большинство записей имеют одинаковое значение TabNum, тогда использование индекса может не принести значительных выгод. В этом случае, поиск по индексу может быть медленнее, чем сканирование всей таблицы.
Если таблица Employees подвержена частым операциям вставки, обновления и удаления записей, то индекс по полю TabNum должен быть обновлен соответствующим образом. Это может вызвать дополнительные затраты на обслуживание индекса и ухудшить производительность операций записи.

Чтобы запрос с использованием индекса гарантированно давал преимущества по сравнению с неиспользованием индекса надо:
- Проанализировать таблицы и определить, какие из них часто обновляются и какие имеют большой объем данных с незначительными изменениями. Для таблиц, которые часто обновляются, следует использовать минимальное количество индексов.
- Для таблиц с большим объемом данных, но незначительными изменениями, применять столько индексов, сколько необходимо для улучшения производительности запросов.
- Использовать кластерные индексы на коротких полях, особенно на столбцах с уникальными значениями, не допускающими NULL. 
- Меньшее количество дубликатов и большее количество уникальных значений повышают работоспособность индекса. Поэтому желательно использовать уникальные индексы.
- Вставлять или модифицировать данные в одном запросе для максимальной эффективности. Множественные одиночные запросы могут негативно сказаться на производительности.
- Создавать некластерные индексы на столбцах, часто используемых в запросах в качестве условий поиска в операторе WHERE и соединениях JOIN.

	Задача 3.

Добавление индекса на столбец DateOfBirth в таблице может значительно улучшить скорость исполнения запроса, особенно если таблица содержит большое количество строк. Индекс позволяет базе данных быстро найти строки, удовлетворяющие условиям запроса, без необходимости полного сканирования всех записей.
Можно внести некоторые изменения в индекс или запрос:
- Вместо создания простого индекса на столбце DateOfBirth, можно рассмотреть возможность создания кластерного индекса или покрывающего индекса, в зависимости от структуры таблицы и других запросов, которые часто выполняются вместе с данным.
- Использовать поле с более высокой кардинальностью: Если столбец DateOfBirth имеет низкую кардинальность (т.е. большое количество строк имеет одинаковое значение), то индексирование может не быть наиболее эффективным. В таких случаях можно рассмотреть индексирование других столбцов с более уникальными значениями.
- Предварительная обработка данных: Вместо применения функции DATEPART к столбцу DateOfBirth в условии WHERE, можно рассмотреть предварительную обработку данных и добавление дополнительного столбца, содержащего только год рождения. Затем можно создать индекс на этом новом столбце и изменить условие запроса, чтобы сравнивать с этим столбцом.

	Задача 4.

Добавление составного индекса на столбцы LastName и DateOfBirth в таблице Employees может оказать положительное влияние на скорость выполнения запроса, особенно если оба столбца активно используются в условиях фильтрации и сортировки.
Можно внести некоторые изменения в индекс или запрос:
- Можно рассмотреть создание индекса с сортировкой в порядке убывания для столбца DateOfBirth, чтобы избежать дополнительной операции сортировки.
- В запросе можно использовать операторы сравнения вместо ORDER BY для фильтрации по дате рождения.

	Задача 5.

Добавление составного индекса на столбцы LastName и DateOfBirth в таблице Employees может иметь некоторое влияние на скорость выполнения запроса, однако в данном  запросе он может не использоваться эффективно из-за отсутствия фильтрации по фамилии (LastName). 
Можно внести некоторые изменения в индекс или запрос:
- Удалить составной индекс или создать дополнительный индекс только на столбце DateOfBirth.
- Если запросы с фильтрацией по дате рождения выполняются часто и требуют высокой производительности, можно рассмотреть предварительную обработку данных и добавление дополнительного столбца, содержащего только год рождения. Затем создать индекс на новом столбце и изменить запрос, чтобы сравнивать с этим столбцом.

	Задача 6.
	
Добавление индекса idx_Employees_Gender_DateOfBirth на столбцы Gender и DateOfBirth в таблице Employees может положительно влиять на скорость выполнения обоих запросов, однако второй запрос, который добавляет условие фильтрации по фамилии LastName, может внести дополнительное улучшение.
Оба запроса получат пользу от индекса idx_Employees_Gender_DateOfBirth, но второй запрос может быть более оптимизированным, так как он добавляет более специфичное условие фильтрации (LastName = N'Иванов'). Это ограничение помогает базе данных более точно и быстро найти соответствующие строки, уменьшая количество строк, которые нужно агрегировать и возвращать.
*/